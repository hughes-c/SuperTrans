<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SuperTrans: transCoherence Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>transCoherence Class Reference</h1><!-- doxytag: class="transCoherence" -->TM Coherency Manager.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;transCoherence.h&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for transCoherence:</div>
<div class="dynsection">
<p><center><img src="classtransCoherence__coll__graph.png" border="0" usemap="#transCoherence__coll__map" alt="Collaboration graph"></center>
<map name="transCoherence__coll__map">
<area shape="rect" href="structtmState.html" title="TM State Container." alt="" coords="5,7,72,31"><area shape="rect" href="structGCMFinalRet.html" title="Structure used to store result of coherence request." alt="" coords="96,7,195,31"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structGCMFinalRet.html">GCMFinalRet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#70cf078923f11d4150016f7c529c87f0">abortEE</a> (thread_ptr pthread, int tid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">eager eager abort  <a href="#70cf078923f11d4150016f7c529c87f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structGCMFinalRet.html">GCMFinalRet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#d07984a43d3b587093a84c1b2a36856b">abortLL</a> (thread_ptr pthread, int tid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lazy lazy abort  <a href="#d07984a43d3b587093a84c1b2a36856b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structGCMFinalRet.html">GCMFinalRet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#d857878a7b70e9becf90f08b410dfd20">beginEE</a> (int pid, icode_ptr picode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">eager eager begin  <a href="#d857878a7b70e9becf90f08b410dfd20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structGCMFinalRet.html">GCMFinalRet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#1e190d0704c3b725c76c399fc03131c2">beginLL</a> (int pid, icode_ptr picode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lazy lazy begin  <a href="#1e190d0704c3b725c76c399fc03131c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#aea009997f9be35f89993ef7b844f242">checkAbort</a> (int pid, int tid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">check to see if thread has been ordered to abort  <a href="#aea009997f9be35f89993ef7b844f242"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structGCMFinalRet.html">GCMFinalRet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#6ba6ffe88fcaabbc37cd3afe79c62566">commitEE</a> (int pid, int tid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">eager eager commit  <a href="#6ba6ffe88fcaabbc37cd3afe79c62566"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structGCMFinalRet.html">GCMFinalRet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#c6debbc1769ff9f6f5e785929b61a732">commitLL</a> (int pid, int tid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lazy lazy commit  <a href="#c6debbc1769ff9f6f5e785929b61a732"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="transCoherence_8h.html#33bf78b86a12281bf786c5c36b1d3df3">GCMRet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#52470d30a8a290846e72bef8ff44d6b4">readEE</a> (int pid, int tid, RAddr raddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">eager eager read  <a href="#52470d30a8a290846e72bef8ff44d6b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="transCoherence_8h.html#33bf78b86a12281bf786c5c36b1d3df3">GCMRet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#628479bca8b3ceaaaab07262e18e678e">readLL</a> (int pid, int tid, RAddr raddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lazy lazy read  <a href="#628479bca8b3ceaaaab07262e18e678e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="682d776874f63985fc77a1ddb031e7a2"></a><!-- doxytag: member="transCoherence::transCoherence" ref="682d776874f63985fc77a1ddb031e7a2" args="(FILE *out, int conflicts, int versioning, int cacheLineSize)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#682d776874f63985fc77a1ddb031e7a2">transCoherence</a> (FILE *out, int conflicts, int versioning, int cacheLineSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b75f164ab1d1cfc20421ac9bbee2f85"></a><!-- doxytag: member="transCoherence::transCoherence" ref="5b75f164ab1d1cfc20421ac9bbee2f85" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#5b75f164ab1d1cfc20421ac9bbee2f85">transCoherence</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global Coherence Module. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="transCoherence_8h.html#33bf78b86a12281bf786c5c36b1d3df3">GCMRet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#6a5073a35891dcf2fb1b38b1da066036">writeEE</a> (int pid, int tid, RAddr raddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">eager eager write  <a href="#6a5073a35891dcf2fb1b38b1da066036"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="transCoherence_8h.html#33bf78b86a12281bf786c5c36b1d3df3">GCMRet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#09669db3c43118a5994ee23e6b8e3275">writeLL</a> (int pid, int tid, RAddr raddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lazy lazy write  <a href="#09669db3c43118a5994ee23e6b8e3275"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structcacheState.html">cacheState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#84fa862a1aba87016310f60a463913ba">newReadState</a> (int pid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create new cache state reference with Read bit set.  <a href="#84fa862a1aba87016310f60a463913ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structcacheState.html">cacheState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#39e80aa4b31470a4e04eb2fe1a08bd73">newWriteState</a> (int pid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create new cache state reference with Write bit set.  <a href="#39e80aa4b31470a4e04eb2fe1a08bd73"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8fa929c89e95529bcaef45d1295fcdda"></a><!-- doxytag: member="transCoherence::currentCommitter" ref="8fa929c89e95529bcaef45d1295fcdda" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#8fa929c89e95529bcaef45d1295fcdda">currentCommitter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PID of the currently committing processor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b4378c9ced1445d83e6e2ca2d086b78"></a><!-- doxytag: member="transCoherence::permCache" ref="1b4378c9ced1445d83e6e2ca2d086b78" args="" -->
map&lt; RAddr, <a class="el" href="structcacheState.html">cacheState</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#1b4378c9ced1445d83e6e2ca2d086b78">permCache</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The cache ownership. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="058e457dfb5ec2bb362bc12847394d89"></a><!-- doxytag: member="transCoherence::utid" ref="058e457dfb5ec2bb362bc12847394d89" args="" -->
long long int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtransCoherence.html#058e457dfb5ec2bb362bc12847394d89">utid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unique Global Transaction ID. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
TM Coherency Manager. 
<p>
Coordinates the entire coherency of the transactional memory system. Read/Write/Abort/Commit/Begin must all be provided and linked to functional pointers at runtime to determine EE/LL/etc. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="70cf078923f11d4150016f7c529c87f0"></a><!-- doxytag: member="transCoherence::abortEE" ref="70cf078923f11d4150016f7c529c87f0" args="(thread_ptr pthread, int tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structGCMFinalRet.html">GCMFinalRet</a> transCoherence::abortEE           </td>
          <td>(</td>
          <td class="paramtype">thread_ptr&nbsp;</td>
          <td class="paramname"> <em>pthread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
eager eager abort 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pthread</em>&nbsp;</td><td>SESC pointer to thread </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>Thread ID </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Final coherency status </dd></dl>

<p>
We can't just decriment because we should be going back to the original begin, so tmDepth[pid] = 0 
</div>
</div><p>
<a class="anchor" name="d07984a43d3b587093a84c1b2a36856b"></a><!-- doxytag: member="transCoherence::abortLL" ref="d07984a43d3b587093a84c1b2a36856b" args="(thread_ptr pthread, int tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structGCMFinalRet.html">GCMFinalRet</a> transCoherence::abortLL           </td>
          <td>(</td>
          <td class="paramtype">thread_ptr&nbsp;</td>
          <td class="paramname"> <em>pthread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lazy lazy abort 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pthread</em>&nbsp;</td><td>SESC thread pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>Thread ID </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Final coherency status </dd></dl>

<p>
We can't just decriment because we should be going back to the original begin, so tmDepth[pid] = 0<p>
Write set size doesn't matter for Lazy/Lazy abort 
</div>
</div><p>
<a class="anchor" name="d857878a7b70e9becf90f08b410dfd20"></a><!-- doxytag: member="transCoherence::beginEE" ref="d857878a7b70e9becf90f08b410dfd20" args="(int pid, icode_ptr picode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGCMFinalRet.html">GCMFinalRet</a> transCoherence::beginEE           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">icode_ptr&nbsp;</td>
          <td class="paramname"> <em>picode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
eager eager begin 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>Process ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>picode</em>&nbsp;</td><td>Instruction code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Final coherency status </dd></dl>

<p>
Subsume all nested transactions for now<p>
This is a subsumed begin, set BCFlag = 2<p>
If we had just aborted, we need to now invalidate all the memory addresses we touched<p>
If we just finished an abort, its time to backoff<p>
Pass whether this is the begining of an aborted replay back to the context<p>
Replay 
</div>
</div><p>
<a class="anchor" name="1e190d0704c3b725c76c399fc03131c2"></a><!-- doxytag: member="transCoherence::beginLL" ref="1e190d0704c3b725c76c399fc03131c2" args="(int pid, icode_ptr picode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGCMFinalRet.html">GCMFinalRet</a> transCoherence::beginLL           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">icode_ptr&nbsp;</td>
          <td class="paramname"> <em>picode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lazy lazy begin 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>Process ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>picode</em>&nbsp;</td><td>SESC icode pointer </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Final coherency status </dd></dl>

<p>
Subsume all nested transactions for now<p>
This begin is subsumed, set the BCFlag to 2<p>
If we had just aborted, we need to now invalidate all the memory addresses we touched<p>
Pass whether this is the begining of an aborted replay back to the context<p>
Replay 
</div>
</div><p>
<a class="anchor" name="aea009997f9be35f89993ef7b844f242"></a><!-- doxytag: member="transCoherence::checkAbort" ref="aea009997f9be35f89993ef7b844f242" args="(int pid, int tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool transCoherence::checkAbort           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
check to see if thread has been ordered to abort 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>Process ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>Thread ID </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Abort? </dd></dl>

</div>
</div><p>
<a class="anchor" name="6ba6ffe88fcaabbc37cd3afe79c62566"></a><!-- doxytag: member="transCoherence::commitEE" ref="6ba6ffe88fcaabbc37cd3afe79c62566" args="(int pid, int tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structGCMFinalRet.html">GCMFinalRet</a> transCoherence::commitEE           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
eager eager commit 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>Process ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>Thread ID </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Final coherency status </dd></dl>

<p>
Set the default BCFlag to 0, since the only other option for Commit is subsumed 2<p>
This commit is subsumed, set the BCFlag to 2<p>
If we have already stalled for the commit, our state will be COMMITTING, Complete Commit<p>
Register Commit in Report 
</div>
</div><p>
<a class="anchor" name="c6debbc1769ff9f6f5e785929b61a732"></a><!-- doxytag: member="transCoherence::commitLL" ref="c6debbc1769ff9f6f5e785929b61a732" args="(int pid, int tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structGCMFinalRet.html">GCMFinalRet</a> transCoherence::commitLL           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lazy lazy commit 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>Process ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>Thread ID </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Final coherency status </dd></dl>

<p>
Set BCFlag default to 0, since only other option is subsumed BCFlag = 2<p>
If we have been forced to ABORT<p>
This is a subsumed commit, set BCFlag = 2<p>
If we have already stalled for the commit, our state will be COMMITTING, Complete Commit<p>
Register Commit in Report<p>
If we have written to this address, we must abort everyone who read/wrote to it<p>
Increase our write set<p>
Abort all who wrote to this<p>
Abort all who read from this<p>
Allow other transaction to commit again<p>
Register Commit in Report<p>
Stop other transactions from being able to commit 
</div>
</div><p>
<a class="anchor" name="84fa862a1aba87016310f60a463913ba"></a><!-- doxytag: member="transCoherence::newReadState" ref="84fa862a1aba87016310f60a463913ba" args="(int pid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcacheState.html">cacheState</a> transCoherence::newReadState           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [read, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create new cache state reference with Read bit set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>Process ID </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Cache state </dd></dl>

</div>
</div><p>
<a class="anchor" name="39e80aa4b31470a4e04eb2fe1a08bd73"></a><!-- doxytag: member="transCoherence::newWriteState" ref="39e80aa4b31470a4e04eb2fe1a08bd73" args="(int pid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcacheState.html">cacheState</a> transCoherence::newWriteState           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [read, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create new cache state reference with Write bit set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>Process ID </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Cache state </dd></dl>

</div>
</div><p>
<a class="anchor" name="52470d30a8a290846e72bef8ff44d6b4"></a><!-- doxytag: member="transCoherence::readEE" ref="52470d30a8a290846e72bef8ff44d6b4" args="(int pid, int tid, RAddr raddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transCoherence_8h.html#33bf78b86a12281bf786c5c36b1d3df3">GCMRet</a> transCoherence::readEE           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAddr&nbsp;</td>
          <td class="paramname"> <em>raddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
eager eager read 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>Process ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>Thread ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>raddr</em>&nbsp;</td><td>Real address </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Coherency status </dd></dl>

<p>
If the cache line has been instantiated in our Map<p>
We haven't, so create a new one 
</div>
</div><p>
<a class="anchor" name="628479bca8b3ceaaaab07262e18e678e"></a><!-- doxytag: member="transCoherence::readLL" ref="628479bca8b3ceaaaab07262e18e678e" args="(int pid, int tid, RAddr raddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transCoherence_8h.html#33bf78b86a12281bf786c5c36b1d3df3">GCMRet</a> transCoherence::readLL           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAddr&nbsp;</td>
          <td class="paramname"> <em>raddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lazy lazy read 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>Process ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>Thread ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>raddr</em>&nbsp;</td><td>Real address </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Coherency status </dd></dl>

<p>
If we have been forced to ABORT<p>
If the cache line has been instantiated in our Map<p>
We haven't, so create a new one 
</div>
</div><p>
<a class="anchor" name="6a5073a35891dcf2fb1b38b1da066036"></a><!-- doxytag: member="transCoherence::writeEE" ref="6a5073a35891dcf2fb1b38b1da066036" args="(int pid, int tid, RAddr raddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transCoherence_8h.html#33bf78b86a12281bf786c5c36b1d3df3">GCMRet</a> transCoherence::writeEE           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAddr&nbsp;</td>
          <td class="paramname"> <em>raddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
eager eager write 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>Process ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>Thread ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>raddr</em>&nbsp;</td><td>Real address </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Coherency status </dd></dl>

<p>
If the cache line has been instantiated in our Map<p>
If there is more than one reader, or there is a single reader who happens not to be us<p>
Grab the first reader than isn't us<p>
Take our timestamp as well as the readers<p>
If the process that is going to nack us is older than us, and we have cycle flag set, abort<p>
If we are older than the guy we're nacking on, then set her cycle flag to indicate possible deadlock<p>
Grab the first reader than isn't us<p>
We haven't, so create a new one 
</div>
</div><p>
<a class="anchor" name="09669db3c43118a5994ee23e6b8e3275"></a><!-- doxytag: member="transCoherence::writeLL" ref="09669db3c43118a5994ee23e6b8e3275" args="(int pid, int tid, RAddr raddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transCoherence_8h.html#33bf78b86a12281bf786c5c36b1d3df3">GCMRet</a> transCoherence::writeLL           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAddr&nbsp;</td>
          <td class="paramname"> <em>raddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lazy lazy write 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>Process ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>Thread ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>raddr</em>&nbsp;</td><td>Real address </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Coherency status </dd></dl>

<p>
If we have been forced to ABORT<p>
If the cache line has been instantiated in our Map<p>
We haven't, so create a new one 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>simulators/sesc/SESC-Gold/src/libtrans/<a class="el" href="transCoherence_8h.html">transCoherence.h</a><li>simulators/sesc/SESC-Gold/src/libtrans/<a class="el" href="transCoherence_8cpp.html">transCoherence.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Sep 7 12:51:52 2009 for SuperTrans by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
